## 问题定位
- 单图模式切换时重复大图解码，邻居预取未产生命中，导致卡顿。
- 大图加载无缓存；预取完成后对象未复用，切换仍需再次 CG 解码。
- 导入/同步阶段在主线程创建 Photo 并同步读取 EXIF/文件属性，存在 UI 阻塞风险。
- 当前大图像素上限固定（4096），在部分窗口下解码开销偏大。
- 切换时交叉淡入与缩放/重置动画叠加，放大了感知延迟。

参考：单图视图与加载 [SinglePhotoView.swift](file:///Users/bytedance/workspace/ai-demo/culler/Culler/Culler/Views/SinglePhotoView.swift)，加载函数 [loadFullImage](file:///Users/bytedance/workspace/ai-demo/culler/Culler/Culler/Views/SinglePhotoView.swift#L201-L248)、邻居预取 [preloadNeighbors](file:///Users/bytedance/workspace/ai-demo/culler/Culler/Culler/Views/SinglePhotoView.swift#L250-L264)；大图生成 [ThumbnailService.generateLargeImage](file:///Users/bytedance/workspace/ai-demo/culler/Culler/Culler/Services/ThumbnailService.swift#L99-L119)，展示图获取 [getDisplayImage](file:///Users/bytedance/workspace/ai-demo/culler/Culler/Culler/Services/ThumbnailService.swift#L52-L75)；键盘导航 [KeyboardShortcutManager](file:///Users/bytedance/workspace/ai-demo/culler/Culler/Culler/Services/KeyboardShortcutManager.swift)。

## 优化方案概览
- 为展示用大图新增内存缓存（NSCache，LRU），配合邻居预取实现即时命中。
- 预取策略：进入/切换时后台预解码前后各1–2张并写入缓存。
- 动态解码尺寸：依据容器尺寸与屏幕 scale 计算目标像素，降低不必要开销。
- 渐进加载：先用已缓存缩略图占位，待大图就绪后平滑替换，避免空白期。
- 将 Photo 的 EXIF/文件属性解析移至后台异步，主线程仅挂载模型。
- 合理聚合安全域访问，减少频繁的 start/stop 调用。
- 精简切换动画：控制交叉淡入/缩放重置的时长与触发条件。

## 具体改动
- 大图缓存
  - 在 [ThumbnailService.swift](file:///Users/bytedance/workspace/ai-demo/culler/Culler/Culler/Services/ThumbnailService.swift) 添加独立 NSCache<NSString, NSImage>，键包含路径 + maxPixelSize。
  - 改造 [getDisplayImage](file:///Users/bytedance/workspace/ai-demo/culler/Culler/Culler/Services/ThumbnailService.swift#L52-L75)：先查缓存，未命中则解码并写入缓存。
  - 设置总内存与条目上限（例如按可用内存比例），使用 LRU 自动回收。
- 邻居预取接入缓存
  - 在 [SinglePhotoView.preloadNeighbors](file:///Users/bytedance/workspace/ai-demo/culler/Culler/Culler/Views/SinglePhotoView.swift#L250-L264) 中调用带缓存的 getDisplayImage，以确保后续切换命中。
  - 预取队列去重与节流：仅在 index 变化时启动，避免重复工作。
- 动态解码尺寸
  - 在 [SinglePhotoView.loadFullImage](file:///Users/bytedance/workspace/ai-demo/culler/Culler/Culler/Views/SinglePhotoView.swift#L201-L248) 计算目标像素：min(容器像素, 上限)，容器像素 = viewSize * screenScale。
  - 将该值传入 ThumbnailService，减少过大解码。
- 渐进加载
  - 切换时立即显示缓存中的缩略图（[PhotoGridView → AsyncThumbnailView](file:///Users/bytedance/workspace/ai-demo/culler/Culler/Culler/Views/PhotoGridView.swift#L287-L376) 已具备缩略获取能力），待大图缓存命中或刚解码完成后替换。
  - 控制交叉淡入时长 ≤ 120ms，避免动画拖延感知速度。
- EXIF/文件信息异步化
  - 在 [Photo.init](file:///Users/bytedance/workspace/ai-demo/culler/Culler/Culler/Models/Photo.swift#L99-L115) 将 [loadFileInfo](file:///Users/bytedance/workspace/ai-demo/culler/Culler/Culler/Models/Photo.swift#L117-L123) 与 [loadEXIF](file:///Users/bytedance/workspace/ai-demo/culler/Culler/Culler/Models/Photo.swift#L125-L163) 改为 Task.detached 后台执行，完成后再回填模型并发布变更。
  - 在 [FolderSyncService](file:///Users/bytedance/workspace/ai-demo/culler/Culler/Culler/Services/FolderSyncService.swift) 保持 UI 主线程安全，避免批量阻塞。
- 安全域访问优化
  - 在 ThumbnailService 中复用对同一 URL 的访问窗口（尽量减少短时间频繁 start/stop）。
- 动画与布局调优
  - 切换时仅在图像资源变更且非命中缓存时进行淡入；命中缓存直接替换。
  - 取消或缩短缩放/位置重置动画，减少布局重算。

## 验证方案
- 埋点与日志
  - 在切换前后记录时间戳：开始导航、缩略显示、大图命中/解码完成、最终渲染完成。
  - 统计 p50/p90 切换耗时；区分缓存命中 vs 解码路径。
- 手动测试
  - 大量高分辨率图片下快速连按左右键；观察是否持续流畅、无白屏。
  - 切换回已浏览过的图片应近乎即时。
  - 导入大量文件时，UI 操作不应明显阻塞。

## 风险与回滚
- 大图缓存可能增加内存占用：通过容量上限与动态像素控制降低风险；随时可关闭或回退到仅缩略缓存。
- 异步 EXIF 解析可能引入时序问题：通过主线程回填与一致性校验保证 UI 正确。

## 实现次序
1) 新增大图缓存并接入 getDisplayImage。
2) 接入邻居预取写缓存与动态像素计算。
3) 渐进加载与动画调优。
4) 异步化 EXIF/文件属性解析。
5) 安全域访问聚合与进一步内存/日志调参。

请确认以上方案，确认后我将开始实现，并给出可量化的加速数据。