**目标**

* 让左侧导航栏与右侧信息栏在应用启动时默认以其最小宽度显示，同时保留用户拖动分隔条后自由调整的能力。

**现状**

* 主布局使用 HSplitView 分为左侧栏、内容区、右侧信息栏：[ContentView.swift](file:///Users/bytedance/workspace/ai-demo/culler/Culler/Culler/Views/ContentView.swift#L47)

* 左侧导航栏当前仅设置了 min/max 宽度（minWidth: 180, maxWidth: 300），未指定默认/理想宽度：[ContentView.swift:L57](file:///Users/bytedance/workspace/ai-demo/culler/Culler/Culler/Views/ContentView.swift#L57)

* 右侧信息栏设置了 min/ideal/max（minWidth: 220, idealWidth: 320, maxWidth: 450），默认会偏向 320 而非最小宽度：[ContentView.swift:L120](file:///Users/bytedance/workspace/ai-demo/culler/Culler/Culler/Views/ContentView.swift#L120)

* 专辑管理页左栏也仅设置了 min/max（minWidth: 200, maxWidth: 300）：[AlbumManagementView.swift:L61](file:///Users/bytedance/workspace/ai-demo/culler/Culler/Culler/Views/AlbumManagementView.swift#L61)

**修改方案**

* 在不引入固定宽度（frame(width:)）的前提下，统一使用 idealWidth 与 minWidth 对齐，令初始布局更倾向最小宽度，同时保持 NSSplitView 的可调整性：

  * ContentView 左侧导航栏：将 `.frame(minWidth: 180, maxWidth: 300)` 改为 `.frame(minWidth: 180, idealWidth: 180, maxWidth: 300)`：[ContentView.swift:L57](file:///Users/bytedance/workspace/ai-demo/culler/Culler/Culler/Views/ContentView.swift#L57)

  * ContentView 右侧信息栏：将 `.frame(minWidth: 220, idealWidth: 320, maxWidth: 450)` 改为 `.frame(minWidth: 220, idealWidth: 220, maxWidth: 450)`：[ContentView.swift:L120](file:///Users/bytedance/workspace/ai-demo/culler/Culler/Culler/Views/ContentView.swift#L120)

  * 专辑管理页左栏：将 `.frame(minWidth: 200, maxWidth: 300)` 改为 `.frame(minWidth: 200, idealWidth: 200, maxWidth: 300)`：[AlbumManagementView.swift:L61](file:///Users/bytedance/workspace/ai-demo/culler/Culler/Culler/Views/AlbumManagementView.swift#L61)

* 不使用 `.frame(width:)`，避免固定宽导致用户无法通过分隔条调整宽度。

* 保留现有 layoutPriority 设置；如需进一步偏向内容区占用空间，可在右侧信息栏降低优先级，但本次无需更改。

**验证**

* 运行应用，观察首次进入：左侧导航栏约为 180pt，右侧信息栏约为 220pt，专辑管理页左栏约为 200pt。

* 拖动分隔条，确认三处仍可在各自 min/max 区间自由调整。

* 切换视图模式（网格/单图/全屏），确认全屏隐藏右栏行为不受影响：[ContentView.swift:L118-L122](file:///Users/bytedance/workspace/ai-demo/culler/Culler/Culler/Views/ContentView.swift#L118-L122)

**影响范围与注意**

* 仅调整宽度偏好（idealWidth），不改变最小/最大约束与布局结构，风险较低。

* 若未来需要“记住用户上次拖动后的宽度”，可引入 @State/@AppStorage 存储并在 onAppear 设置 frame(width:) 初值，同时监听分隔条变化（需要桥接 NSSplitView）；本次不包含该持久化功能。

